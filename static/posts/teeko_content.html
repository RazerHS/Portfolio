<div class="content">
    <!-- <img src='posts/Teeko/teeko_gameplay.gif'> -->
    
    <div class="spacing-m"></div>
    <div class="steam-widget-container">
        <iframe class="hide-on-mobile" src="https://store.steampowered.com/widget/3650150/" frameborder="0" width="500" height="191"></iframe>  
            <div class="hide-on-desktop wishlist-button glass">
                <a href="https://store.steampowered.com/app/3650150/Teeko/" target="_blank"><p>Wishlist Here!</p></a>
                <img class="steam-logo" src="/steam_logo.png" alt="Steam Logo">
            </div>
        <img src='/lags_badge_2025.png'>
    </div>
    <div class="spacing-xl"></div>
    <div class="trailer">
        <iframe src="https://www.youtube.com/embed/XooBIDYGdEw" title="Teeko - Official Trailer | Latin American Games Showcase 2025" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>               
    </div>
    
    <p>I setup complex game architecture or useful tools to help the team work faster. One important aspect I contributed to was the <color class='color1'>Story Graph</color>, a narrative design tool that could support dialogue across many NPCs, levels, and languages. </p>
    <p>Many iterations later, the Story Graph became the backbone of Teeko’s efficient and easy-to-use narrative pipeline. You can read more about it down below: </p>

    <button class='glass collapsable'><h2>The Story Graph</h2></button>
    <div class='collapsable-content glass collapsable-hidden'>
        <p>Prior to development, I surveyed the narrative team and collected a feature/usability list to make the Story Graph more relevant for our workflow than external solutions. After some more research, I found that the experimental Unity Graph API (which ShaderGraph is built upon) had built-in functionality to cover many important features, so it was chosen as the <color class='color3'>basis</color> for the Story Graph.</p>
        
        <h3>So What Can It Do?</h3>
        <p>The Story Graph consists of an editor window containing a node graph, a minimap, and a toolbar for renaming, saving, and loading. </p>
        <img src='posts/Teeko/storygraph_img_1.png'>

        <p>Each node has a node type (START, NONE, END) which represents where in the story passage you are. The START node has additional settings, such as whether this passage should be wrapped in a letterbox and the name of the passage. Nodes are connected each to continue a passage until it hits an END node.</p>
        <img src='posts/Teeko/storygraph_img_2.png'>

        <p>For this project, only linear dialogue was required, so branching functionality was stripped out. This is what a branching passage looked like in previous versions: </p>
        <img src='posts/Teeko/storygraph_img_3.png'>
        
        <p>All nodes also contain their own data which can be added or removed easily, as these fields are drawn using Odin Inspector. Adding additional fields required quite a bit of manual setup in UI toolkit, so to simplify the process, I configured Odin to draw them in ImGUI and then inserted them within an ImGUI container for use in UI toolkit.</p>
        
        <div class="code-snippet">
            <pre><code class="cs">public void DrawNodeProperties(DialogueNode dialogueNode)
{
    IMGUIContainer mainImGuiContainer = new IMGUIContainer(OnDrawPropertyTree);

    dialogueNode.propertyTree = PropertyTree.Create(Data);

    dialogueNode.mainContainer.Add(mainImGuiContainer);
}           </code></pre>
        </div>
        
        <div class="code-snippet">
            <pre><code class="cs">[Serializable]
public class DialogueNodeData
{
    [SerializeField, ColoredBoxGroup("Passage Settings", true, true), ShowIf("nodeType", NodeType.START)] private bool showLetterbox;
    [SerializeField, ColoredBoxGroup("Data", false, 0.6f, 0.1f, 0.1f), LabelWidth(70)] private CharacterData speaker;
    [SerializeField, ColoredBoxGroup("Data"), LabelWidth(70), LabelText("SFX")] private SFXAsset sfxAsset;
    [SerializeField, ColoredBoxGroup("Data"), LabelWidth(70), EnumPaging, LabelText("Face")] private FacialExpressionType facialExpression;
    [SerializeField, ColoredBoxGroup("Data"), LabelWidth(70), HideLabel, TextArea] private string dialogueText;

...         </code></pre>
        </div>
       
        <h3>Pretty Animation Previews</h3>
        <p>To animate dialogue text, we use Febucci’s Text Animator, in which previewing text was only possible inside of Text Mesh Pro in the editor. This made it tedious to visualize specific animations of our dialogue lines, so to make this easier, I set up a custom stage that instantiated our dialogue box and inserted any dialogue you hover within the story graph. </p>    
        <img src='posts/Teeko/storygraph_img_6.gif'>

        <div class="code-snippet">
            <pre><code class="cs">private void CreateScenePreview()
{
    if (dialogueWidgetPreviewPrefab == null)
    {
        return;
    }

    previewStage = CreateInstance<DialoguePreviewStage>();

    GameObject previewObject = Instantiate(dialogueWidgetPreviewPrefab);

    StageUtility.GoToStage(previewStage, true);
    SceneManager.MoveGameObjectToScene(previewObject, previewStage.scene);

    currentDialogueWidgetPreview = previewStage.scene.GetRootGameObjects()[0].GetComponentInChildren<BackgroundDialogueWidget>();

    if (currentDialogueWidgetPreview == null)
    {
        throw Log.Exception("Background dialogue widget component not found in root game object of preview!");
    }
}           </code></pre>
        </div>

        <p>By using the mouse, you could stop and play the text’s current animations. Combined with a prefab of our actual dialogue widget, you can get a proper dialogue preview within the story graph:</p>
        <img src='posts/Teeko/storygraph_img_8.gif'>

        <h3>Reflection</h3>
        <p>I loved working on this tool because of how much depth and detail I could focus on to make it as useful and time-saving as possible for the narrative team. Not only that, but I also learned a lot about systems built into Unity and how they work on a more granular level. Overall, it was a big success!</p>
        <img src='posts/Teeko/storygraph_img_9.gif'>

        <p>A big edge the Story Graph has over other dialogue solutions I tried in the past, such as Twine and Articy. Since its data is stored using scriptable objects, using it with source control was extremely straightforward and let us easily keep track of versioning, as well as allowing multiple people to work on different story graphs simultaneously. </p>
        <img src='posts/Teeko/storygraph_img_10.png'>

        <p>Future extensions of the Story Graph include a level scripting mode, allowing you to make dialogue impact the game world itself (example here) and localization support.</p>
    
        <div class="collapsable-end-divider"></div>      
    </div>

    <div class="spacing-m"></div>

    <!-- <button class='glass collapsable'><h2>Story Events</h2></button>
    <div class='collapsable-content glass collapsable-hidden'>
    </div> -->

    <div class="post-end-divider"></div>      
</div>