<div class="content">
    <p>In the world of the <color class='color2'>future</color>, would we still have physical money? Physical phones? Physical data? It is this world that we were tasked to portray by our clients at the DitLab at the Hanze University of Sciences. They are involved with research regarding SSI, or self-sovereign identity, a solution to safely storing decentralized data on digital wallets.</p>
    <p>As such, we created a futuristic murder mystery detective game showcasing the world’s transition between physical and digital data. As you learn more about the scene, you find out how data doesn’t leave the same <color class='color3'>traces</color> that it did before, as well as some potential drawbacks of decentralized data. </p>
    <img src='posts/Grigorostok/weather_img_11.png'>

    <p>My team and I spent 4 months researching, concepting, prototyping and evaluating our incorporation of SSI into an interactive medium. As the team’s <color class='color1'>lead</color> programmer, I was responsible for our game’s architecture, gameplay, tools, and performance, and shaders.</p>
    <p>During this project, I tried to push my creative and technical bounds to see what I was capable of creating. Read about some of these endeavors below: </p>    
    <button class='glass collapsable'><h2>Dynamic Weather System</h2></button>
    <div class='collapsable-content glass collapsable-hidden'>
        <h3>Finding the Balance</h3>
        <p>To carefully craft the ambience for our level, I built a dynamic weather system that can customize various post-processing, weather, and lighting settings from the editor. Since our game operates on a 24h in-game clock system, the config allows the user to specify weather parameters for each hour of the day.</p>
        <img src='posts/Grigorostok/weather_img_1.png'>
        <img src='posts/Grigorostok/weather_img_8.png'>

        <p>Each aspect of the weather had its own lower and upper bounds precalculated and set to already look good for our level. As such, when our designer sets a parameter from [0-1], it gets mapped to the pre-established bounds. This helps avoid artifacts when the system procedurally mixes all the parameters and creates new weather conditions.</p>
        <img src='posts/Grigorostok/weather_img_2.png'>
        
        <div class="code-snippet">
            <pre><code class="cs">private void SetCurrentEvaluatedWeatherDataByDay(int day, float percentage)
{
    ...

    float rainStrength = sceneConfig.WeatherDataList[index].EvaluateRainStrength(percentage);

    float newExposure = Mathf.Lerp(sceneConfig.NighttimeExposure, sceneConfig.DaytimeExposure, CustomExposureRemap(sunController.CurrentSunRotation, sceneConfig.ExposureMinimumSunRotationAngle, sceneConfig.ExposureMaximumSunRotationAngle));

    SetExposure(newExposure);
    SetGlobalWindSpeed(Mathf.Lerp(sceneConfig.WindSpeedBounds.x, sceneConfig.WindSpeedBounds.y, windStrength));

    SetFog(Mathf.Lerp(sceneConfig.FogAttenuationDistanceBounds .x, sceneConfig.FogAttenuationDistanceBounds.y, 1 - fogStrength));
    SetRainStrength(rainStrength);
    SetGroundRainDropSpeed(Mathf.Lerp(sceneConfig.RainDropSpeedBounds.x, sceneConfig.RainDropSpeedBounds.y, rainStrength));

    CalculateWetness(rainStrength, percentage);
    SetWetness(wetness);

    ...

    SetRainParticleEmission(rainStrength);

    ChangeWeatherForRandomParameters(percentage, windStrength);
}           </code></pre>
        </div>

        <h3>Droplets Galore</h3>
        <p>To prevent the weather from being too static, certain lower-impact properties were handled by chance. Combined with the user-set parameters for each day, the same values can have slight variation in their appearance across different days, which is more akin to real-world weather.</p>
        <img src='posts/Grigorostok/weather_img_3.png'>
        
        <div class="code-snippet">
            <pre><code class="cs">private void ChangeWeatherForRandomParameters(float percentage, float windStrength)
{
    if (randomWeatherParameters == null)
    {
        CalculateNewRandomWeatherParameters();
        CalculateNewTimeToChangeWeatherParameters(percentage);
    }

    float adjustedCurrentTimePercentage = CalculateAdjustedCurrentTimePercentage(percentage, timeUntilNextWeatherChange);
    float percentageUntilParametersFullyChanged = Mathf.InverseLerp(startTimeOfCurrentWeatherChange, timeUntilNextWeatherChange, adjustedCurrentTimePercentage);

    ...  

    rainZoneManager.SetRainParticleRotation(windDirection, windStrength, sceneConfig.MaximumRainTiltAngle);

    if (percentageUntilParametersFullyChanged < 1f)
    {
        return;
    }

    CalculateNewRandomWeatherParameters();
    CalculateNewTimeToChangeWeatherParameters(percentage);
}           </code></pre>
        </div>

        <p>To visually map our 24h time with Unity’s AnimationCurve fields, I used Odin Inspector’s progress bar and set its width to be that of the animation curves. This way, the user can move the progress bar and use it as a reference for setting each property at a specified time of day and link it to important narrative beats.</p>
        <img src='posts/Grigorostok/weather_img_4.png'>
        <img src='posts/Grigorostok/weather_img_5.png'>
        
        <p>I also found excellent references from Ben Cloward to create the ground rain/droplet shader, in which I exposed many of the properties which the weather system controls. It visually ties together rain strength with how many droplets appear on the ground, how many puddles it creates and how long they linger, as well as how many rain particles fall from the sky.</p>
        <img src='posts/Grigorostok/weather_img_6.gif'>
        <img src='posts/Grigorostok/weather_img_9.png'>
        <img src='posts/Grigorostok/weather_img_10.png'>
    
        <h3>Final Thoughts</h3>
        <p>Ultimately, our team did not have enough time within the project to implement all designed narrative beats and map them to the most compelling weather conditions. However, I learned a lot about controlling multitudes of different effects and procedurally shaping them to match real-life references and hope to use the system in other cool projects.</p>
        <p>Next steps include making a visual showcase of the changing weather and smoothing out certain weather changes, such as the rapid and textured disappearing of clouds in HDRP and the sun’s bloom deactivating when behind a cloud.</p>
    
        <div class="collapsable-end-divider"></div>      
    </div>

    <button class='glass collapsable'><h2>Asset Importer</h2></button>
    <div class='collapsable-content glass collapsable-hidden'>
        <h3>Modural Design</h3>
        <p>To build our level, we decided to create modular building blocks and have our level designer compose each building himself based on his city layout. While this was a great solution for our small team, it meant that each time we had an iteration of new building assets, we would need to spend a lot of time doing manual importing and setup.</p>
        <img src='posts/Grigorostok/importer_img_3.png'>
        <img src='posts/Grigorostok/importer_img_1.png'>

        <p>To save a significant amount of manual work and reduce human error during this process, I built a tool to take in an .fbx file and a shader and automate the following:</p>
        <ul>
            <li>Extract the model's materials.</li>
            <li>Find the corresponding textures within the same directory by name.</li>
            <li>Apply the textures to the shader based on the exposed shader properties.</li>
            <li>Rename the textures using the model name and texture type (correcting potential typos).</li>
            <li>Remap the materials back into the model.</li>
        </ul>
        <video src='posts/Grigorostok/importer_demo.mp4' controls loop='true' autoplay='true'></video>      

        <p>I also included a debug section to make sure textures and materials were found properly in case something wasn’t working as intended, as well as some config settings depending on the tool’s use case.</p>
        <img src='posts/Grigorostok/importer_img_2.png'>
        
        <h3>A Time Save Hack</h3>
      
        <p>Using this tool saved us hours and hours of manual labor of dragging textures and materials all over the place - all with just the click of a button! I very much enjoyed digging deeper into Unity and finding solutions for features such as manually extracting the materials from a model (like in the Inspector) and fetching exposed shader properties.</p>
    
        <div class="code-snippet">
            <pre><code class="cs">private List&lt;Material&gt; ExtractMaterials(string modelPath)
{
    int result = 0;

    try
    {
        AssetDatabase.StartAssetEditing();

        HashSet&lt;string&gt; assetsToReload = new HashSet&lt;string&gt;();

        IEnumerable&lt;Object&gt; materialsToExtract = AssetDatabase.LoadAllAssetsAtPath(modelPath).Where(x => x.GetType() == typeof(Material));

        foreach (Object material in materialsToExtract)
        {
            result++;

            string newAssetPath = modelPath[..(modelPath.Length - model.name.Length - 4)] + material.name + ".mat";

            newAssetPath = AssetDatabase.GenerateUniqueAssetPath(newAssetPath);
            string error = AssetDatabase.ExtractAsset(material, newAssetPath);

            if (string.IsNullOrEmpty(error))
            {
                assetsToReload.Add(modelPath);
            }
        }
            
        foreach (string path in assetsToReload)
        {
            AssetDatabase.WriteImportSettingsIfDirty(path);
            AssetDatabase.ImportAsset(path, ImportAssetOptions.ForceUpdate);
        }
    }

    finally
    {
        AssetDatabase.StopAssetEditing();
    }

    List&lt;Material&gt; extractedMaterials = LoadAllAssetsAtPath&lt;Material&gt;(Path.GetDirectoryName(modelPath));

    if (result == 0 && extractedMaterials.Count != 0)
    {
        Log.Write("Materials already extracted.");
    }

    Log.Write($"Loaded &lt;b&gt;{extractedMaterials.Count}&lt;/b&gt; materials from the model's directory!");

    return extractedMaterials;
}           </code></pre>
        </div>

        <div class="code-snippet">
            <pre><code class="cs">private List<string> GetShaderPropertyList()
{
    List<string> properties = new();

    if (shader == null)
    {
        return properties;
    }

    int propertyCount = shader.GetPropertyCount();

    for (int i = 0; i &lt; propertyCount; i++)
    {
        if ((shader.GetPropertyFlags(i) & ShaderPropertyFlags.HideInInspector) != 0)
        {
            continue;
        }

        if (shader.GetPropertyType(i) != ShaderPropertyType.Texture)
        {
            continue;
        }

        properties.Add(shader.GetPropertyName(i));
    }

    return properties;
}           </code></pre>
        </div>
        
        <p>Next steps would include automatically replacing each model in its corresponding prefab or game object, but due to time constraints during the project, other tasks were prioritized instead. However, that would be a great next step for integrating the tool into other projects and making its own stand-alone asset.</p>
    
        <div class="collapsable-end-divider"></div>      
    </div>

    <div class="post-end-divider"></div>      
</div>

